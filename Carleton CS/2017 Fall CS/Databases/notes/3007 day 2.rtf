{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 3007 day 2\
\
\
Schemes rule of evaluating things\
1. 
\b Evaluate
\b0  subexpression of combination\
- recursive\'85\
- determine what something is\
 \
2.  Apply\
- apply what the things are with one another\
\
- called when subexpressions are all evaluated and we hit a closing bracket\
\
Eval;  \
When something is not self evlauating ( clear what it is, like *is multiplication) , we then have to dive in and walk through the subexpressions in the expression\
\
\
Exception to the eval-apply rule is involved in defining variables. There we do not have the evaluation of the word define because it is not a procedure.\
\
\
\
2 forms to evaluate expressions in function usage ( and subexpressions)\
\
Applicative order\
- sub in the numbers for the variable. Bind them\
- then last call the function to which the newly bonded numbers exist in. \
\
\
Normal order\
- evaluate the procedure\'85and continue on doing so until you are left with no procedures left\
- call the function first\
- called lazy evaluation \
\
\
** normal vs applicative order will be on a test **\
\
Special Form\
-Ex. If statement\
-Special form is anything that does not follow applicative order\
- if is special form because it will not evaluate the whole statement.\
}